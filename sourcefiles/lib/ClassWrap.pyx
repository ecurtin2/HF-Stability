# This File was automatically generated by CppClassWrapper
########################################################################
#                             .pyx Header                              #
########################################################################
# cython: profile=False
# cython: boundscheck=False
# cython: wraparound=False

from libcpp cimport bool
from libc.math cimport sqrt
import itertools
import math
from scipy import special as sp
import numpy as np
cimport numpy as np
cimport cython

# This group imports from ./lib
include "lib/cyarma.pyx"    
from lib import general_methods as gm


########################################################################
#                      Generated cpp->pyx Header                       #
########################################################################
cdef extern from "stability.h" namespace "HFStability":
    cdef cppclass HEG:
        #Attributes
        double  bzone_length, vol, rs, kf, kmax, fermi_energy
        double  two_e_const, deltaK
        long long unsigned int    Nocc, Nvir, Nexc, N_elec, Nk
        int ndim
        vec  occ_energies, vir_energies, exc_energies, kgrid
        vec vectest
        vec vectest1
        vec vectest2
        mat mattest
        umat occ_states, vir_states, excitations
        #Methods
        double mvec_test()
        vec mat_vec_prod(vec)
        void   calc_energy_wrap(bool)
        void   calc_exc_energy()
        long long unsigned int get_k_to_idx(double[])
        void get_vir_states_inv()
        void   calc_energies(umat&, vec&)
        double exchange(umat&, long long unsigned int)
        double two_electron(vec, vec)
        double two_electron_check(vec, vec, vec, vec)
        double get_1B(long long unsigned int, long long unsigned int)
        double get_3B(long long unsigned int, long long unsigned int)
        double get_1A(long long unsigned int, long long unsigned int)
        double get_3A(long long unsigned int, long long unsigned int)
        double get_3H(long long unsigned int, long long unsigned int)
        void to_first_BZ(vec&)
        void get_inv_exc_map()
        void get_vir_N_to_1_map()
        uvec inv_exc_map_test


########################################################################
#                              pyx class                               #
########################################################################
cdef class PyHEG:
    cdef HEG* c_HEG
    def __cinit__(self):
        self.c_HEG = new HEG()
    def __dealloc__(self):
        del self.c_HEG


    #All constants of calculation specified by __init__
    #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
    def __init__(self, ndim=3, rs=1.0, Nk=4):
        """This is an init docstring"""
        self.rs = float(rs)
        self.ndim = int(ndim)
        self.Nk = int(Nk)
        self.get_resulting_params()
    
    def get_resulting_params(self):
        """Given rs, ndim, Nk, determine other parameters
    
        Description:
                Does nothing if all 3 aren't defined, which shouldn't
                ever be possible.
        Args:
                No args
        Returns:
                Nothing
        Raises:
                No exceptions
                
    
        """
        # It looks like the variables default to 0, not undefined
        # Because c++ defines it
        if self.rs == 0 or self.ndim == 0 or self.Nk == 0:
            return None
        try:
            self.rs
            self.ndim
            self.Nk
        except:
            return None #Don't try to calc resulting params until all defined!
        else:
            pass #Continue on if it checks out
    
        ##### IMPORTANT!!! THIS ORDER MATTERS FROM HERE!!!! #######
        if self.ndim == 1:
            self.kf = np.pi / (4 * self.rs)
        elif self.ndim == 2:
            self.kf = 2**0.5 / self.rs
        elif self.ndim == 3:
            self.kf = (9 * np.pi / 4)**(1./3.) * (1. / self.rs) 
    
        self.kmax = 2.0 * self.kf
        self.fermi_energy = 0.5 * self.kf**2
        #brillioun zone is from - pi/a .. pi/a
        self.bzone_length =  2.0 * self.kmax
        self.kgrid = np.linspace(-self.kmax, self.kmax, self.Nk)
        self.deltaK = self.kgrid[1] - self.kgrid[0]
    
        self.calc_occ_states()
    
        if self.ndim == 3:
            self.vol = self.N_elec * 4.0 / 3.0 * np.pi * (self.rs**3)
            self.two_e_const = 4.0 * np.pi / self.vol 
        elif self.ndim == 2:
            self.vol = self.N_elec * np.pi * (self.rs**2)
            self.two_e_const = 2.0 * np.pi / self.vol 
        elif self.ndim == 1:
            self.vol = self.N_elec * 2.0 * self.rs
        
        self.calc_occ_energies()
        self.calc_vir_states()
        self.calc_vir_energies()
        self.calc_exc_energies()
        assert np.all(self.occ_energies < self.fermi_energy) , (
               'Not all occupied energies are below fermi energy')
        # The converse can not be said for the virtual states, since the exchange
        # interaction reduces the energies wrt the non-interacting case. Thus some virtual 
        # states lie lower in energy compared to the unperturbed fermi level.
        # the perturbed fermi level is not calculated here, as I don't need it. 
        assert np.all(self.exc_energies > 0.0), ( 
               'Not all excitation energies are positive')
        ##### IMPORTANT!!! THIS ORDER MATTERS UNTIL HERE!!!! #######
    
    def calc_occ_states(self):
        """ayy docstring"""
        ary_list = [self.kgrid] * self.ndim
        allcombos = np.array(gm.cartesian(ary_list))
        rownorms = np.sqrt((allcombos * allcombos).sum(axis=1))
        condition_ary = rownorms <= self.kf + 10E-8
        indices = self.k_to_index(allcombos[condition_ary])
        self.occ_states = np.asfortranarray(indices, dtype=np.uint64)
        self.Nocc = len(self.occ_states)
        #RHF ONLY
        self.N_elec = 2 * self.Nocc
    
    def calc_possible_exc(self):
        x_exc = (self.kgrid + self.kmax)[1:]         #all potential +x excitations within 1st BZ
        all_exc = np.zeros((self.Nk - 1, self.ndim)) # -1 excludes the occ_state
        all_exc[:,0] = x_exc                         #only consider +x,  y and z are zero
        num_add = self.Nk - 1                        # max number of excitations in 1D
        my_ones = np.ones((num_add), dtype=int)
        N = self.Nocc * num_add
        occ_idx = np.zeros((N), dtype=np.uint64)
        vir = np.zeros((N, self.ndim), dtype=np.float64)
        i1 = 0
        i2 = num_add
        occ_states_k = self.kgrid[self.occ_states]
        for index, state in enumerate(occ_states_k):
            a = all_exc + state
            b = index * my_ones
            occ_idx[i1:i2] = b
            vir[i1:i2] = a
            i1 += num_add
            i2 += num_add
        vir_norms = np.sqrt((vir*vir).sum(axis=1))  #norm of each row
        idx= np.where((vir_norms > self.kf+10E-8) & (np.all(vir <= self.kmax + 10E-8, axis=1)))
        vir = vir[idx]          # keep only those above fermi but below cutoff
        occ_idx = occ_idx[idx]  # this is the occupied state that generated the vir
        return occ_idx, self.k_to_index(vir)
    
    def unique_rows(self, data):                 
        """Return only unique rows
        see http://stackoverflow.com/questions/31097247/remove-duplicate-rows-of-a-numpy-array"""
        sorted_idx = np.lexsort(data.T)
        sorted_data =  data[sorted_idx,:]
        row_mask = np.append([True],np.any(np.diff(sorted_data,axis=0),1))
        new_idx = 0
        #EASY SPEED HERE PREALLOCATE BUT PROBS NOT NEEDED
        # unique_map maps the unfiltered row to the filtered row
        unique_map = [0]
        for i in row_mask[1:]:
            if i:
                new_idx += 1
            unique_map.append(new_idx)
    
        unique_map = np.asarray(unique_map, dtype=int)
        return sorted_data[row_mask], unique_map, sorted_idx
    
    def calc_vir_states(self):
        occ_idx, non_unique_virs = self.calc_possible_exc()
        unique_virs, unique_map, sorted_idx = self.unique_rows(non_unique_virs) #keep only unique
    
        self.vir_states = np.asfortranarray(unique_virs, dtype=np.uint64)
        self.Nvir = len(unique_virs)
        occ_idx = occ_idx[sorted_idx]  # the virs have been shuffled, update occ positions
        exc = np.column_stack((occ_idx, unique_map))
        exc = np.asfortranarray(exc, dtype=np.uint64)
        self.excitations = exc
        self.Nexc = len(exc)
    
    def calc_exc_energies(self):
        self.c_HEG.calc_exc_energy()
    
    def calc_occ_energies(self):
        self.c_HEG.calc_energy_wrap(False) # False = occupied energies
    
    def calc_vir_energies(self):
        self.c_HEG.calc_energy_wrap(True) # True = virtual energies
    
    def f2D(self, y):
        if y <= 1.0:
            #scipy and guiliani/vignale define K and E differently, x -> x*x
            return sp.ellipe(y*y)
        else:
            #scipy and guiliani/vignale define K and E differently, x -> x*x
            x = 1.0 / y
            return y * (sp.ellipe(x*x) - (1.0 - x*x) * sp.ellipk(x*x))
    
    def f3D(self, y):
        if y < 10e-10:
            return 1.0
        return 0.5 + (1 - y*y) / (4*y) * math.log(abs((1+y) / (1-y)))
    
    def analytic_exch(self, k):
        const = -2.0 * self.kf / math.pi
        if self.ndim == 2:
            return const * self.f2D(k/self.kf)
        elif self.ndim == 3:
            return const * self.f3D(k/self.kf)
    
    def analytic_energy(self, k):
        x = np.linalg.norm(k)  #works on k of any dimension
        return (x*x / 2.0) + self.analytic_exch(x)
    
    def k_to_index(self, array):
        idx = np.rint(((array + self.kmax) / self.deltaK)).astype(np.uint64)
        assert np.all(np.isclose(self.kgrid[idx], array)), 'Error in momentum to index transform.'
        return idx
    
    def get_inv_exc_map(self):
        self.c_HEG.get_inv_exc_map()
        test = self.inv_exc_map_test
        assert np.all(test == np.arange(len(test))), 'Inverse excitation map (2D) Incorrect.'
        
    def mv_test(self):
        self.c_HEG.mvec_test()


########################################################################
#                         Generated Properties                         #
########################################################################
    def get_bzone_length(self):
        """(float) Get/Set bzone_length"""
        return self.c_HEG.bzone_length
    def set_bzone_length(self, value):
        self.c_HEG.bzone_length = float(value)
    bzone_length = property(get_bzone_length, set_bzone_length)
    

    def get_vol(self):
        """(float) Get/Set vol"""
        return self.c_HEG.vol
    def set_vol(self, value):
        self.c_HEG.vol = float(value)
    vol = property(get_vol, set_vol)
    

    def get_rs(self):
        """(float) Get/Set rs"""
        return self.c_HEG.rs
    def set_rs(self, value):
        self.c_HEG.rs = float(value)
    rs = property(get_rs, set_rs)
    

    def get_kf(self):
        """(float) Get/Set kf"""
        return self.c_HEG.kf
    def set_kf(self, value):
        self.c_HEG.kf = float(value)
    kf = property(get_kf, set_kf)
    

    def get_kmax(self):
        """(float) Get/Set kmax"""
        return self.c_HEG.kmax
    def set_kmax(self, value):
        self.c_HEG.kmax = float(value)
    kmax = property(get_kmax, set_kmax)
    

    def get_fermi_energy(self):
        """(float) Get/Set fermi_energy"""
        return self.c_HEG.fermi_energy
    def set_fermi_energy(self, value):
        self.c_HEG.fermi_energy = float(value)
    fermi_energy = property(get_fermi_energy, set_fermi_energy)
    

    def get_two_e_const(self):
        """(float) Get/Set two_e_const"""
        return self.c_HEG.two_e_const
    def set_two_e_const(self, value):
        self.c_HEG.two_e_const = float(value)
    two_e_const = property(get_two_e_const, set_two_e_const)
    

    def get_deltaK(self):
        """(float) Get/Set deltaK"""
        return self.c_HEG.deltaK
    def set_deltaK(self, value):
        self.c_HEG.deltaK = float(value)
    deltaK = property(get_deltaK, set_deltaK)
    

    def get_Nocc(self):
        """(int) Get/Set Nocc"""
        return self.c_HEG.Nocc
    def set_Nocc(self, value):
        self.c_HEG.Nocc = int(value)
    Nocc = property(get_Nocc, set_Nocc)
    

    def get_Nvir(self):
        """(int) Get/Set Nvir"""
        return self.c_HEG.Nvir
    def set_Nvir(self, value):
        self.c_HEG.Nvir = int(value)
    Nvir = property(get_Nvir, set_Nvir)
    

    def get_Nexc(self):
        """(int) Get/Set Nexc"""
        return self.c_HEG.Nexc
    def set_Nexc(self, value):
        self.c_HEG.Nexc = int(value)
    Nexc = property(get_Nexc, set_Nexc)
    

    def get_N_elec(self):
        """(int) Get/Set N_elec"""
        return self.c_HEG.N_elec
    def set_N_elec(self, value):
        self.c_HEG.N_elec = int(value)
    N_elec = property(get_N_elec, set_N_elec)
    

    def get_Nk(self):
        """(int) Get/Set Nk"""
        return self.c_HEG.Nk
    def set_Nk(self, value):
        self.c_HEG.Nk = int(value)
    Nk = property(get_Nk, set_Nk)
    

    def get_ndim(self):
        """(int) Get/Set ndim"""
        return self.c_HEG.ndim
    def set_ndim(self, value):
        self.c_HEG.ndim = int(value)
    ndim = property(get_ndim, set_ndim)
    

    def get_occ_energies(self):
        """(np.ndarray[double, ndim=1]) Get/Set occ_energies"""
        return vec_to_numpy(self.c_HEG.occ_energies)
    def set_occ_energies(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.occ_energies = numpy_to_vec_d(value)
    occ_energies = property(get_occ_energies, set_occ_energies)
    

    def get_vir_energies(self):
        """(np.ndarray[double, ndim=1]) Get/Set vir_energies"""
        return vec_to_numpy(self.c_HEG.vir_energies)
    def set_vir_energies(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.vir_energies = numpy_to_vec_d(value)
    vir_energies = property(get_vir_energies, set_vir_energies)
    

    def get_exc_energies(self):
        """(np.ndarray[double, ndim=1]) Get/Set exc_energies"""
        return vec_to_numpy(self.c_HEG.exc_energies)
    def set_exc_energies(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.exc_energies = numpy_to_vec_d(value)
    exc_energies = property(get_exc_energies, set_exc_energies)
    

    def get_kgrid(self):
        """(np.ndarray[double, ndim=1]) Get/Set kgrid"""
        return vec_to_numpy(self.c_HEG.kgrid)
    def set_kgrid(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.kgrid = numpy_to_vec_d(value)
    kgrid = property(get_kgrid, set_kgrid)
    

    def get_vectest(self):
        """(np.ndarray[double, ndim=1]) Get/Set vectest"""
        return vec_to_numpy(self.c_HEG.vectest)
    def set_vectest(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.vectest = numpy_to_vec_d(value)
    vectest = property(get_vectest, set_vectest)
    

    def get_vectest1(self):
        """(np.ndarray[double, ndim=1]) Get/Set vectest1"""
        return vec_to_numpy(self.c_HEG.vectest1)
    def set_vectest1(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.vectest1 = numpy_to_vec_d(value)
    vectest1 = property(get_vectest1, set_vectest1)
    

    def get_vectest2(self):
        """(np.ndarray[double, ndim=1]) Get/Set vectest2"""
        return vec_to_numpy(self.c_HEG.vectest2)
    def set_vectest2(self, np.ndarray[double, ndim=1] 
                     value not None):
        self.c_HEG.vectest2 = numpy_to_vec_d(value)
    vectest2 = property(get_vectest2, set_vectest2)
    

    def get_mattest(self):
        """(np.ndarray[double, ndim=2, mode="fortran"]) Get/Set mattest"""
        return mat_to_numpy(self.c_HEG.mattest)
    def set_mattest(self, np.ndarray[double, ndim=2, mode="fortran"] 
                     value not None):
        self.c_HEG.mattest = numpy_to_mat_d(value)
    mattest = property(get_mattest, set_mattest)
    

    def get_occ_states(self):
        """(np.ndarray[long long unsigned int, ndim=2, mode="fortran"]) Get/Set occ_states"""
        return umat_to_numpy(self.c_HEG.occ_states)
    def set_occ_states(self, np.ndarray[long long unsigned int, ndim=2, mode="fortran"] 
                     value not None):
        self.c_HEG.occ_states = numpy_to_umat_d(value)
    occ_states = property(get_occ_states, set_occ_states)
    

    def get_vir_states(self):
        """(np.ndarray[long long unsigned int, ndim=2, mode="fortran"]) Get/Set vir_states"""
        return umat_to_numpy(self.c_HEG.vir_states)
    def set_vir_states(self, np.ndarray[long long unsigned int, ndim=2, mode="fortran"] 
                     value not None):
        self.c_HEG.vir_states = numpy_to_umat_d(value)
    vir_states = property(get_vir_states, set_vir_states)
    

    def get_excitations(self):
        """(np.ndarray[long long unsigned int, ndim=2, mode="fortran"]) Get/Set excitations"""
        return umat_to_numpy(self.c_HEG.excitations)
    def set_excitations(self, np.ndarray[long long unsigned int, ndim=2, mode="fortran"] 
                     value not None):
        self.c_HEG.excitations = numpy_to_umat_d(value)
    excitations = property(get_excitations, set_excitations)
    

    def get_inv_exc_map_test(self):
        """(np.ndarray[long long unsigned int, ndim=1]) Get/Set inv_exc_map_test"""
        return uvec_to_numpy(self.c_HEG.inv_exc_map_test)
    def set_inv_exc_map_test(self, np.ndarray[long long unsigned int, ndim=1] 
                     value not None):
        self.c_HEG.inv_exc_map_test = numpy_to_uvec_d(value)
    inv_exc_map_test = property(get_inv_exc_map_test, set_inv_exc_map_test)
    



