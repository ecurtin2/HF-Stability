/** @file main.cpp
@author Evan Curtin
@version Revision 0.1
@brief Main function for Hartree-Fock stability.
@details For the release version, the parameters are
taken as command line input.
@date Wednesday, 04 Jan, 2017
*/

/**
@mainpage
This is the Documentation page generated by Doxygen for the Hartree-
Fock stability of the Homogeneous Electron Gas.
*/


/*
This program is incomplete in the following ways
1. Does not play well with MPI.
*/

#include "main.hpp"
#include "NDmap.hpp"
#include <iomanip>
#include <string>

int main(int argc, char* argv[]){
    // Start the timers
    std::chrono::time_point<std::chrono::system_clock> thetime;
    thetime = std::chrono::system_clock::now();
    std::time_t end_time = std::chrono::system_clock::to_time_t(thetime);
    HFS::computation_started = std::string(std::ctime(&end_time));
    arma::wall_clock timer;
    timer.tic();

    // Defaults
    HFS::rs              = 1.2;
    HFS::Nk              = 7;
    HFS::mycase          = "cRHF2cUHF";
    HFS::OutputFileName  = "HFS.json";

    HFS::dav_tol         = 1e-6;
    HFS::dav_maxits      = 20;
    HFS::dav_max_subsize  = 750;

    // As Nk increases, the initial space and block size
    // need to be bigger to accound for density/degeneracy in
    // the eigenvalue spectrum.

    HFS::dav_num_evals   = 1;
    HFS::twoE_parameter_1dCase = 1;
    HFS::use_delta_1D = false;

    /* Set options from command line. False means error won't be thrown if
       value is not found, and default will be used. */
    ConfigParser parser(argc, argv);
    parser.set_val(HFS::rs, "--rs", false);
    parser.set_val(HFS::Nk, "--Nk", false);
    parser.set_val(HFS::mycase, "--mycase", false);
    parser.set_val(HFS::OutputFileName, "--fname", false);
    parser.set_val(HFS::dav_tol, "--Dav_tol", false);
    parser.set_val(HFS::dav_maxits, "--Dav_maxits", false);
    parser.set_val(HFS::dav_max_subsize, "--Dav_maxsubsize", false);
    parser.set_val(HFS::dav_num_evals, "--Dav_num_evals", false);
    parser.set_val(HFS::twoE_parameter_1dCase, "--twoE_parameter_1dCase", false);
    parser.set_val(HFS::use_delta_1D, "--use_delta_1D", false);


    /* Calculation starts here */
    HFS::calcParameters();
    HFS::Matrix::setMatrixPropertiesFromCase(); // RHF-UHF etc instability, matrix dimension
    //HFS::timeMatrixVectorProduct();

    HFS::num_guess_evecs = 100;
    HFS::dav_blocksize   = HFS::ground_state_degeneracy;

    /* Default values for these are calculated, but may be
    overridden from command line */
    parser.set_val(HFS::num_guess_evecs, "--num_guess_evecs", false);
    parser.set_val(HFS::dav_blocksize, "--Dav_blocksize", false);

	if (HFS::num_guess_evecs > HFS::Nexc) {
			  HFS::num_guess_evecs = HFS::Nexc;
	}


    std::vector<PetscErrorCode (*)(Mat, Vec, Vec)> mvproducts(4);
    std::vector<scalar> dav_vals(4);
    enum cases {Triplet_A_Plus_B, Triplet_A_Minus_B,
                Singlet_A_Plus_B, Singlet_A_Minus_B};

    mvproducts[Triplet_A_Plus_B] = SLEPc::Petsc_Mv_Triplet_A_Plus_B;
    mvproducts[Triplet_A_Minus_B] = SLEPc::Petsc_Mv_Triplet_A_Minus_B;
    mvproducts[Singlet_A_Plus_B] = SLEPc::Petsc_Mv_Singlet_A_Plus_B;
    mvproducts[Singlet_A_Minus_B] = SLEPc::Petsc_Mv_Singlet_A_Minus_B;

    int i = 0;
    for (auto mv: mvproducts) {
        SLEPc::EpS myeps(HFS::Nexc, mv);
        myeps.SetDimensions(HFS::dav_num_evals, HFS::dav_max_subsize);
        myeps.SetTol(HFS::dav_tol, HFS::dav_maxits);
        myeps.SetBlockSize(HFS::dav_blocksize);

        std::vector< std::vector<scalar> > vecs(HFS::num_guess_evecs, std::vector<scalar>(HFS::Nmat, 0.0));
        for (uint i = 0; i < HFS::num_guess_evecs; ++i) {
            arma::vec guessvec;
            arma::vec temp = arma::abs(HFS::exc_energies[i] - HFS::exc_energies) + 1;
            guessvec = (1.0 / temp);
            guessvec /= arma::norm(guessvec);
            vecs[i] = arma::conv_to< std::vector<scalar> >::from(guessvec);
        }
        myeps.SetInitialSpace(vecs);

        HFS::N_MV_PROD = 0;
        arma::wall_clock davtimer;
        davtimer.tic();
        myeps.Solve();
        HFS::dav_time = davtimer.toc();
        arma::vec temp(myeps.rVals);
        HFS::dav_vals = temp;
        HFS::dav_its = myeps.niter;
        HFS::dav_nconv = myeps.nconv;
        HFS::cond_number = HFS::exc_energies(HFS::exc_energies.n_elem-1) / HFS::exc_energies(0);
        if (HFS::dav_nconv >= 1) {
            dav_vals[i] = HFS::dav_vals.min();
        } else {
            dav_vals[i] = 1.0 / 0.0;
        }
        HFS::Total_Calculation_Time = timer.toc();
        i += 1;
    }

    HFS::dav_triplet_a_plus_b = dav_vals[Triplet_A_Plus_B];
    HFS::dav_triplet_a_minus_b = dav_vals[Triplet_A_Minus_B];
    HFS::dav_singlet_a_plus_b = dav_vals[Singlet_A_Plus_B];
    HFS::dav_singlet_a_minus_b = dav_vals[Singlet_A_Minus_B];

    PetscInt myrank;
    MPI_Comm_rank(PETSC_COMM_WORLD, &myrank);
    PetscErrorCode ierr = SlepcFinalize();CHKERRQ(ierr);


    if (myrank == 0) {
    #ifndef NDEBUG
        arma::mat A(HFS::Nexc, HFS::Nexc);
        arma::mat B(HFS::Nexc, HFS::Nexc);
        for (unsigned i = 0; i < HFS::Nexc; ++i) {
            for (unsigned j = 0; j < HFS::Nexc; ++j) {
                A(i, j) = HFS::Matrix::Gen::A_E_delta_ij_delta_ab_minus_aj_bi(i, j);
                B(i, j) = HFS::Matrix::Gen::B_minus_ab_ji(i, j);
            }
        }

        std::cout << "Values determined by full diagonalization:" << std::endl;
        arma::vec evals;
        arma::eig_sym(evals, A+B);
        std::cout << "Triplet A+B min = " << evals.min() << std::endl;
        arma::eig_sym(evals, A-B);
        std::cout << "Triplet A-B min = " << evals.min() << std::endl;
        arma::mat H = arma::join_cols(arma::join_rows(A, B), arma::join_rows(B, A));
        arma::eig_sym(evals, H);
        std::cout << "Triplet H min = " << evals.min() << std::endl;

        arma::mat sA(HFS::Nexc, HFS::Nexc);
        arma::mat sB(HFS::Nexc, HFS::Nexc);
        for (unsigned i = 0; i < HFS::Nexc; ++i) {
            for (unsigned j = 0; j < HFS::Nexc; ++j) {
                sA(i, j) = HFS::Matrix::Gen::A_E_delta_ij_delta_ab_plus_2aj_ib_minus_ajbi(i, j);
                sB(i, j) = HFS::Matrix::Gen::B_minus_abji_plus_2abij(i, j);
            }
        }

        arma::eig_sym(evals, sA+sB);
        std::cout << "singlet A+B min = " << evals.min() << std::endl;
        arma::eig_sym(evals, sA-sB);
        std::cout << "singlet A-B min = " << evals.min() << std::endl;
        H = arma::join_cols(arma::join_rows(sA, sB), arma::join_rows(sB, sA));
        arma::eig_sym(evals, H);
        std::cout << "singlet H min = " << evals.min() << std::endl;
    #endif //NDEBUG
    } // myrank == 0

    if (myrank == 0) {
        HFS::writeJSON(HFS::OutputFileName, false);
    }
    return 0;
}
