/** @file main.cpp
@author Evan Curtin
@version Revision 0.1
@brief Main function for Hartree-Fock stability.
@details For the release version, the parameters are
taken as command line input.
@date Wednesday, 04 Jan, 2017
*/

/**
@mainpage
This is the Documentation page generated by Doxygen for the Hartree-
Fock stability of the Homogeneous Electron Gas.
*/

#include <iostream>
#include <cmath>
#include <assert.h>
#include <chrono>
#include <ctime>
#include <stdio.h>

#include "parameters.hpp"
#include "cmd_parser.hpp"
#include "base_funcs.hpp"
#include "calc_parameters.hpp"
#include "NDmap.hpp"
#include "matrix_vectorproducts.hpp"
#include "debug.hpp"
#include "fileIO.hpp"
#include "SLEPcWrapper.hpp"

/*
This program is incomplete in the following ways
1. Does not play well with MPI.
*/

int main(int argc, char* argv[]){

    // Defaults
    rs              = 1.2;
    Nk              = 18;
    mycase          = "cRHF2cUHF";
    OutputFileName  = "HFS.json";

    dav_tol         = 1e-6;
    dav_maxits      = 30;
    dav_max_subsize = 1500;
    num_guess_evecs = 1;
    dav_blocksize   = 1;
    dav_num_evals   = 1;

    /* Set options from command line. False means error won't be thrown if
       value is not found, and default will be used. */
    ConfigParser parser(argc, argv);
    parser.set_val(rs, "--rs", false);
    parser.set_val(Nk, "--Nk", false);
    parser.set_val(mycase, "--mycase", false);
    parser.set_val(OutputFileName, "--fname", false);
    parser.set_val(dav_tol, "--Dav_tol", false);
    parser.set_val(dav_maxits, "--Dav_maxits", false);
    parser.set_val(dav_max_subsize, "--Dav_maxsubsize", false);
    parser.set_val(num_guess_evecs, "--num_guess_evecs", false);
    parser.set_val(dav_blocksize, "--Dav_blocksize", false);
    parser.set_val(dav_num_evals, "--Dav_num_evals", false);

    /* Calculation starts here */
    params PhysicalParams(rs, Nk, mycase);
    Matrix::setMatrixPropertiesFromCase(); // RHF-UHF etc instability, matrix dimension

    # if NDIM != 1
        SLEPc::EpS myeps(Nmat, MatVecProduct_func);
        myeps.SetDimensions(dav_num_evals, dav_max_subsize);
        myeps.SetTol(dav_tol, dav_maxits);
        myeps.SetBlockSize(dav_blocksize);

        // Choose guess eigenvectors for davidson. Weight by how close diags are.
        std::vector< std::vector<scalar> > vecs(num_guess_evecs, std::vector<scalar>(Nmat, 0.0));
        for (uint i = 0; i < num_guess_evecs; ++i) {
            arma::vec guessvec;
            arma::vec temp = arma::abs(exc_energies[i] - exc_energies) + 1;
            guessvec = (1.0 / temp);
            guessvec /= arma::norm(guessvec);
            vecs[i] = arma::conv_to< std::vector<scalar> >::from(guessvec);
        }

        // Davidson Algorithm
        myeps.SetInitialSpace(vecs);
        arma::wall_clock davtimer;
        davtimer.tic();
        myeps.Solve();
        dav_time = davtimer.toc();
        arma::vec temp(myeps.rVals);
        dav_vals = temp;
        dav_its = myeps.niter;
        dav_nconv = myeps.nconv;
        dav_min_eval = dav_vals.min();
    #endif // NDIM != 1
    # if NDIM == 1
        arma::wall_clock eval_timer;
        eval_timer.tic();
        arma::mat matrix = Matrix_generator();
        arma::vec eigvals;
        arma::mat eigvecs;
        arma::eig_sym(eigvals, eigvecs, matrix);
        full_diag_min = eigvals.min();
        full_diag_time = eval_timer.toc();
        exact_evals = eigvals;
    # endif // NDIM
    Total_Calculation_Time = timer.toc();

    // Finish up, write and test for problems.
    #ifndef NDEBUG
        auto M = Matrix_generator();
        assert(matrixVectorProductWorks(M, MatVecProduct_func) && "There is a problem in the matrix-vector product.");
        if (Nmat < 1500) {
            assert(agreesWithFullDiag() && "Davidson's Algorithm Didn't get the lowest eigenvalue.");
        }
        if ( !everything_works() ) {
            exit(EXIT_FAILURE);
        }
    #endif //NDEBUG

    writeJSON(OutputFileName, true);

    return 0;
}
